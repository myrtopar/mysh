Παραδοχές:

1) Τα commands που δεχεται το shell τρεχουν με αυθαιρετο αριθμο κενων αναμεσα τους.
2) Ο συνδυασμος pipes και redirect λειτουργει μονο ως εξης: command_1 | ... | command_n > output. To shell δεν 
   μπορει να χειριστει ανακατευθυνσεις αναμεσα στις σωληνωσεις, παρα μονο στο τελος αυτων.
3) Σε περιπτωση εντολης με πολλαπλες ανακατευθυνσεις εξοδου, το αποτελεσμα θα γραφτει μονο στο τελευταιο αρχειο 
   εξοδου.

Το κελυφος αποτελειται απο ενα μεγαλο while loop που περιμενει να διαβασει εντολη απο το τερματικο με την συναρτηση
fgets. Πριν γινει οποιαδηποτε διαδικασια, βρισκει καποια flags τα οποια δηλωνουν εαν η τρεχουσα εντολη που μολις 
διαβαστηκε εχει μεσα ανακατευθυνσεις, σωληνωσεις, εκτελεση στο background η καποιο wildcaard (* ή ?).

Επειτα η συναρτηση add_whitespaces χρησιμοποιειται για να δεσμευσει δυναμικα ενα νεο string, οπου θα αντιγραφει η 
εντολη που διαβαστηκε μεσω της fgets, και θα τοποθετηθουν κενα γυρω απο τα συμβολα >, <, >>, |, σε περιπτωση που
τα συμβολα αυτα ειναι κολλημενα με τις υπολοιπες λεξεις της εντολης. 

Στη συνεχεια ακολουθει το parsing της γραμμης που δημιουργηθηκε στην συναρτηση add_whitespaces. Το parsing γινεται
με delimeters το whitespace και το tab. Το καθε token τοποθετειται σε εναν πινακα char **token_array. Μετα τον δεικτη
στην τελευταια λεξη της εντολης, ακολουθει NULL το οποιο δηλωνει το τελος της εντολης.

Πριν την εκτελεση της εντολης, ακολουθουν καποιοι ελεγχοι για το περιεχομενο της εντολης:
-Εαν η πρωτη λεξη της εντολης ειναι "myhistory" και η δευτερη ειναι ψηφιο ή NULL, καλει τις καταλληλες συναρτησεις (θα
 εξηγηθουν παρακατω), και συνεχιζει στην fgets.
-Εαν η πρωτη λεξη της εντολης ειναι "exit", κανει break, και το προγραμμα τερματιζει.
-Εαν η πρωτη λεξη της εντολης ειναι "createalias" ή "destroyalias", καλει τις καταλληλες συναρτησεις (θα εξηγηθουν παρακατω),
 και συνεχιζει στην fgets.


**  Alias  **
Πριν εκτελεστει η εντολη, γινεται ελεγχος εαν αυτη η εντολη ειναι alias καποιας εντολης unix. Η συναρτηση search_alias
ψαχνει σειριακα την δομη/πινακα alias_array και ελεγχει εαν το token[0] ειναι alias. Εαν δεν ειναι alias, ο κωδικας 
προχωραει παρακατω στον ελεγχο για wildcards.

Δομη για την αποθηκευση των aliases: πινακας  aliasnode *alias_array[30] ο οποιος περιεχει 30 δεικτες σε struct aliasnode
(οριζεται στο functions.h). Καθε struct aliasnode περιεχει το ονομα του alias και την εντολη στην οποια αντιστοιχει και
δημιουργειται και δεσμευεται μνημη για καθε τετοιο struct στην συναρτηση createalias. Η συναρτηση destroyalias αντιστοιχα
διαγραφει το alias και αποδεσμευει το αντιστοιχο struct. H συναρτηση search_alias δεχεται σαν ορισμα ενα char *alias και 
ψαχνει στον πινακα να δει εαν υπαρχει aliasnode για αυτο το alias. Εαν βρει, επιστρεφει ολοκληρο το aliasnode.
Στην περιπτωση που το shell λαβει καποια εντολη που ειναι alias καποιας αλλης, ψαχνει με την χρηση της search_alias να βρει
το aliasnode που περιεχει την εντολη Unix που αντιστοιχει σε αυτο το alias. Μολις την βρει, κανει parse την πραγματικη
εντολη, ενημερωνει το token array και το token count με τα tokens της πραγματικης εντολης και προχωραει παρακατω.


**  Wildcards  **
To wildcard_flag παιρνει τιμη 1 εαν υπαρχουν * ή ? ή και τα 2. Σε αυτη την περιπτωση καλειται η συναρτηση expand_wildcard.
Αυτη η συναρτηση κανει expand το token που περιεχει wildcard με χρηση της glob. Επειτα κανει ακριβως την ιδια δουλεια που
κανει το shell για την εκτελεση εντολων (εκτελεση εντολης/ανακατευθυνσεις/σωληνωσεις), και επιστρεφει. Ο κωδικας συνεχιζει 
περιμενοντας νεα εντολη απο το τερματικο. 


**  Απλες Εντολες  **
Η συναρτηση που εκτελει απλες εντολες ειναι η execute_simple_command. Καλειται μονο οταν υπαρχει καποια εντολη που δεν εχει
ουτε σωληνωσεις ουτε ανακατευθυνσεις (πχ cat file.txt). Γινεται fork, και μεσα στην διεργασια παιδι γινεται execvp με το
token_array που εχει περαστει ως παραμετρος στην συναρτηση. Η διεργασια του κελυφους περιμενει την διεργασια παιδι με waitpid.


**  Εντολες με Ανακατευθυνσεις  **
Η συναρτηση που εκτελει εντολες με ανακατευθυνσεις ΜΟΝΟ ειναι η handle_redirections. Διατρεχει σειριακα το token_array. Εαν 
συναντησει καποιο token που ειναι ειτε > ειτε >> προκειται για ανακατευθυνση εξοδου. Κανει open to token_array[i+1] δηλαδη το 
output file που εχει γραψει ο χρηστης (αναλογα αν ειναι απλη ανακατευθυνση η ανακατευθυνση προσθηκης, η open εχει τα καταλληλα 
flags οπως O_TRUNC, O_APPEND κλπ), κανει fork και στην διεργασια παιδι αντιγραφει το file descriptor του standard output και το 
κανει αντιγραφη του file descriptor του αρχειου εξοδου με την dup2. 
Αντιστοιχα αν συναντησει καποιο token που ειναι < προκειται για ανακατευθυνση εισοδου. Με αναλογο τροπο κανει fork και στην διεργασια 
παιδι αντιγραφει το file descriptor του standard input και το κανει αντιγραφη του file descriptor του αρχειου εισοδου με την dup2.
Στην διεργασια του shell, μετα το περας των exec, το κελυφος περιμενει τα παιδια με waitpid.


**  Εντολες με Σωληνωσεις  **
Η συναρτηση που εκτελει εντολες με σωληνωσεις ειναι η handle_pipes. H handle_pipes παιρνει απο τα ορισματα τον αριθμο των σωληνωσεων
που υπαρχουν στην εντολη. Δημιουργει απο την αρχη εναν 2d πινακα απο ints με τοσες στηλες οσες και οι σωληνωσεις και 2 γραμμες. Εκει 
αποθηκευονται οι file descriptors των 2 ακρων των σωληνωσεων που δημιουργουνται στη συνεχεια.  
Η εντολη θα εχει την μορφη command_1 | ... | command_n στην γενικη περιπτωση οποτε εαν υπαρχει n πληθος εντολων, θα υπαρχουν n-1 pipes.
Σε καθε token του token_array που περιεχει "|", μπαινει NULL για να δηλωνει το "τελος" καθε εντολης (αυτο γινεται με την null_delim).
Πχ το token array για την εντολη file.txt | sort | uniq ειναι: "file.txt" NULL "sort" NULL "uniq" NULL. Aυτο θα χρησιμευσει αργοτερα 
οταν θα γινει το execvp.
Γινεται ενα for loop στο διαστημα [0, num_pipes+1] και σε καθε επαναληψη γινεται ενα fork. To καθε παιδι της επαναληψης κληρονομει ολα τα 
pipes που δημιουργηθηκαν προηγουμενως στον πατερα. 
1. Αμα βρισκομαστε στην πρωτη επαναληψη δηλαδη στην διεργασια-παιδι που εχει φτιαχτει για το command_1, θα κανουμε μονο dup2 το standard
   output στο write end του pipe ωστε αντι να παει η εντολη προς εκτελεση να γραψει στο standard output, να γραψει στο write end του pipe 0.

2. Aμα βρισκομαστε στην τελευταια επαναληψη δηλαδη στην διεργασια-παιδι που εχει φτιαχτει για το command_n, θα κανουμε μονο dup2 το standard
   input στο read end του pipe ωστε αντι να παει η εντολη προς εκτελεση να διαβασει απο το standard input, να διαβασει απο το read end 
   του pipe n-1. **υποπεριπτωση αν υπαρχει στο τελος των σωληνωσεων ανακατευθυνση σε αρχειο εξοδου: ανοιγει το αρχειο στο οποιο θα μπει το
   output και ο file descriptor του γινεται copy στο standard output ωστε οποιοδηποτε αποτελεσμα να παει να γραφει στο αρχειο εξοδου.**

3. Αμα βρισκομαστε σε καποια ενδιαμεση επαναληψη δηλαδη στην διεργασια παιδι που εχει φτιαχτει για το command_k, 0 < k < n+1, θα κανουμε 
   2 dup2, ενα για να αντιγραψουμε το standard input στο read end του pipe k-1 για να διαβασει το αποτελεσμα της προηγουμενης εντολης, και
   ενα για να αντιγραψουμε το standard output στο write end του pipe k για να γραψει το αποτελεσμα της τρεχουσας εντολης προς εκτελεση στο
   write end ωστε να μπορει να το διαβασει η επομενη εντολη.

Μετα απο ολα τα dup2, κλεινουμε ολα τα ακρα απο ολα τα pipes που κληρονομησε το τρεχον παιδι στην τρεχουσα επαναληψη και καλειται η execvp.
O πινακας με τα tokens που θα παρει η execvp καθοριζεται ως εξης: 
Χρησιμοποιωντας την συναρτηση command_to_exec, ζηταμε απο τα ορισματα την i-οστη εντολη (απο την i-οστη επαναληψη του for) και η command_to_exec
επιστρεφει το index στον πινακα token_array οπου βρισκεται η οπου ξεκιναει η i-οστη εντολη.
πχ.  το token array για την εντολη file.txt | sort | uniq ειναι: "file.txt" NULL "sort" NULL "uniq" NULL. Εαν καλεσουμε την command_to_exec
για την 2η εντολη, ζηταμε το index στο token_array οπου ξεκιναει η δευτερη εντολη δηλαδη η sort. Ετσι η συναντηση θα επιστρεψει το index 3
και με αυτον τον τροπο θα δωσουμε στην execvp την διευθυνση &token_array[3]. 

Στην διεργασια πατερα, αφου πλεον εχουν δημιουργηθει και τρεξει ολες οι εντολες και τα pipes, κλεινουν ολα τα ακρα των σωληνωσεων και η
συναρτηση επιστρεφει.


** Εκτελεση Εντολων στο background  **
Για να τρεξω εντολες με & στο background κανω τα παρακατω:
-Αρχικα φτιαχνω ενα group process στην αρχη του shell με process group id το ιδιο το pid του shell επομενως θετω το κελυφος ως leader του 
 process group. Του δινω τον ελεγχο του τερματικου με την tcsetpgrp.
-Χωριζω τις εντολες προς εκτελεση σε 2 κατηγοριες: Στις foreground εντολες και στις background εντολες. Καθε φορα που γινεται fork για να
 εκτελεστει μια εντολη (ανεξαρτητου σωληνωσεων, ανακατευθυνσεων κλπ), γινεται ελεγχος μεσω του flag background εαν ειναι εντολη παρασκηνιου
 η εντολη προσκηνιου. Στην καθε περιπτωση δημιουργειται ενα process group με leader την ιδια την διεργασια.
-Στις εντολες που ειναι foreground, το process group παιρνει τον ελεγχο του τερματικου με την tcsetpgrp και κανουν exec. Αντιθετα για τις 
 εντολες που ειναι background, το process group δεν παιρνει τον ελεγχο του τερματικου, οποτε ετσι εκτελουνται στο παρασκηνιο, και τυχον 
 εκτυπωσεις γινονται κανονικα στο τερματικο χωρις να επεμβαινουν στο τρεξιμο των αλλων εντολων.
-Η διεργασια του shell κανει wait μονο για τις διεργασιες foreground, αφηνοντας τις υπολοιπες να τρεχουν στο background ανενοχλητες. Το 
 shell επιστρεφει τον ελεγχο του τερματικου στον εαυτο του με την tcsetpgrp.
-Στην περιπτωση σωληνωσεων, η πρωτη εντολη των σωληνωσεων δημιουργει το process group με leader τον εαυτο της και οποιαδηποτε επομενη εντολη
 αναμεσα στις σωληνωσεις μπαινει στο process group της αρχικης


** History **
Υπαρχει ενας πινακας που κραταει τις 20 τελευταιες εντολες που δεχτηκε το shell. Η εντολη "myhistory" εμφανιζει αυτες τις εντολες.
Στην περιπτωση που ο χρηστης πληκτρολογησει "myhistory n" οποτ 0 < n < 20, θα εκτελεστει η n-οστη εντολη απο το τελος. Δηλαδη με την 
εντολη "myhistory 1" θα εκτελεστει η τελευταια εντολη που πληκτρολογηθηκε απο τον χρηστη.





 
